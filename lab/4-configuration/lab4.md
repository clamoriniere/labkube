# Configuration

Configuration of an application may be done through:

- Environment Variables
- Files
- Services

Grabbing your configuration using a Service is something that you can do using the Service Discovery as described in lab4

Environment variables can directly be set inside the pod definition at container level. We had an example with HOSTNAME in the first lab:

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: labkube
  name: labkube-env
spec:
  containers:
  - image: cedriclamoriniere/labkube:v1
    env:                                    # <-- section for environment variables
    - name: MY_LABKUBE_VAR
      value: "Hello from the environment"
    name: labkube
    ports:
    - containerPort: 8080
```

It is possible to inject in environment variables some values that comes from different sources ( see the api [here](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#envvarsource-v1-core) ):

- fieldRef: pod information. You have access to the invariant information such as:
  - metadata.name
  - metadata.namespace
  - spec.nodeName
  - spec.serviceAccountName
  - status.hostIP
  - status.podIP
- resourceFieldRef: information about limits and requests of memory and cpu
- configMapKeyRef: values associated to a key i a configmap
- secretKeyRef: values associated to a key i a configmap

Note that the `metadta.name` value is already injected in the environment variable `HOSTNAME`

## Exercices

### Exercise 1

Modify the pod definition and create a pod containing a variable NAMESPACE.

### Exercise 2

Modify the pod definition and create a pod containing a variable with a label. Does it work? why?

## ConfigMap

A configmap allow you inject files in your pod. The configmap content can be modified, so that the new file content is distributed to all the pod using that config map.

You can create a configmap from file or directory directly using kubectl:

```console
> kubectl create configmap myconfig --from-file=configfolder
configmap "myconfig" created
```

Let's check the content of the create object:

```console
> kubectl get cm myconfig -oyaml
```

```yaml
apiVersion: v1
data:
  file1.txt: content of file1
  file2.txt: content of file 2
kind: ConfigMap
metadata:
  creationTimestamp: 2018-07-05T09:46:05Z
  name: myconfig
  namespace: default
  resourceVersion: "157692"
  selfLink: /api/v1/namespaces/default/configmaps/myconfig
  uid: 3c303bb3-8038-11e8-a9a4-0800270f19f1
```

Let's consume that configmap in our pod. 

First let's use environment variables with deployment-1

```console
> kubectl create -f deployment-1.yaml
deployment "labkube-cm" created
```

Here the section that was added to the deployment

```yaml
env:
        - name: KEY_FROM_CM
          valueFrom:
            configMapKeyRef:
              name: myconfig
              key: file1.txt
```

Check the container environment

```console
> kubectl exec labkube-cm-bdc6b5749-8sqsx -- env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=labkube-cm-bdc6b5749-8sqsx
KEY_FROM_CM=content of file1
MY_DEPLOYMENT=My deployment is labkube-cm
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
...
```

Now let's make a deployment that consume the configmap as files

```console
> kubectl create -f deployment-2.yaml 
deployment "labkube-cmfile" created
```

In our deployment we had to append 2 sections:

- One to declare a volume and associate it to the configmap
- One to mount the volume in the container

```yaml
    spec:
      containers:
      - image: cedriclamoriniere/labkube:v1
        ...
        volumeMounts:
        - name: configmap-volume
          mountPath: /etc/cm
      volumes:
        - name: configmap-volume
          configMap:
            name: myconfig
```

### Exercise

#### Exercise 1

Enter the pod generated by the last deployment and find where the file was injected. Check the content of the file.

#### Exercice 2

Change the content of the configmap using `edit`. Check that the file is modified inside you pod.